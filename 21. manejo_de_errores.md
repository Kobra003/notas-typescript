# Manejo de Errores en TypeScript

## Introducci√≥n

El manejo de errores es crucial para escribir c√≥digo robusto y evitar fallos inesperados. TypeScript proporciona herramientas para manejar errores de forma segura y con mejor tipado.

üìå **Motivos para manejar errores correctamente:**  
‚úî Evita que la aplicaci√≥n falle inesperadamente.  
‚úî Facilita la depuraci√≥n y el mantenimiento del c√≥digo.  
‚úî Mejora la experiencia del usuario al proporcionar mensajes de error claros.


## Uso de `try...catch`

La forma est√°ndar de manejar errores en TypeScript es mediante `try...catch`.

```typescript
try {
  throw new Error("¬°Ocurri√≥ un error!");
} catch (error) {
  console.log("Error:", error);
}
```

`throw` lanza un error y `catch` lo captura.


## Tipado del Error en `catch`

Por defecto, TypeScript considera que `error` es de tipo `any`, pero podemos usar el tipo `unknown` para mayor seguridad.

```typescript
try {
  throw new Error("Error inesperado");
} catch (error: unknown) {
  if (error instanceof Error) {
    console.log("Error:", error.message);
  } else {
    console.log("Error desconocido");
  }
}
```

Usar `unknown` nos obliga a verificar el tipo antes de acceder a sus propiedades.


## Creaci√≥n de Errores Personalizados

Podemos definir **clases de error personalizadas** heredando de `Error`.

```typescript
class MiError extends Error {
  constructor(mensaje: string) {
    super(mensaje);
    this.name = "MiError";
  }
}

try {
  throw new MiError("Algo sali√≥ mal");
} catch (error) {
  if (error instanceof MiError) {
    console.log("Error personalizado:", error.message);
  }
}
```

√ötil para manejar **tipos espec√≠ficos de errores** en la aplicaci√≥n.


## Manejo de Errores en Funciones As√≠ncronas

Si una funci√≥n es `async`, podemos manejar los errores con `try...catch`.

```typescript
async function obtenerDatos() {
  try {
    let respuesta = await fetch("https://api.ejemplo.com/datos");
    let datos = await respuesta.json();
    console.log(datos);
  } catch (error) {
    console.error("Error al obtener datos:", error);
  }
}

obtenerDatos();
```

**Importante**: Siempre envolver `await` en un `try...catch` para manejar errores de red.


## `Promise.catch()` como Alternativa

En lugar de `try...catch`, podemos usar `.catch()` al final de una `Promise`.

```typescript
fetch("https://api.ejemplo.com/datos")
  .then(respuesta => respuesta.json())
  .then(datos => console.log(datos))
  .catch(error => console.error("Error en la petici√≥n:", error));
```

√ötil para manejar errores en una cadena de promesas sin `async/await`.


## `finally`: C√≥digo que Siempre se Ejecuta

El bloque `finally` se ejecuta **siempre**, sin importar si hubo error o no.

```typescript
try {
  console.log("Intentando ejecutar...");
  throw new Error("Fall√≥ la operaci√≥n");
} catch (error) {
  console.log("Error:", error);
} finally {
  console.log("Esto siempre se ejecuta");
}
```

√ötil para **cerrar conexiones** o **limpiar recursos**.


## Uso de `asserts` para Validaciones

TypeScript permite usar **aserciones (`asserts`)** para verificar condiciones.

```typescript
function esNumero(valor: any): asserts valor is number {
  if (typeof valor !== "number") {
    throw new Error("El valor no es un n√∫mero");
  }
}

function calcularDoble(valor: any) {
  esNumero(valor);
  return valor * 2; // Aqu√≠ TypeScript ya sabe que es un n√∫mero
}

console.log(calcularDoble(5)); // ‚úÖ 10
console.log(calcularDoble("hola")); // ‚ùå Error
```

**Ventaja**: Mejora el tipado y previene errores antes de que ocurran.


## Evitando `any` en Errores

Siempre que sea posible, evitar el uso de `any` en el manejo de errores y preferir `unknown`.

üö´ **Mal uso (`any`)**

```typescript
try {
  throw "Error desconocido";
} catch (error: any) {
  console.log(error.message); // ‚ùå Puede fallar si el error no es un objeto
}
```

‚úÖ **Mejor uso (`unknown`)**

```typescript
try {
  throw "Error desconocido";
} catch (error: unknown) {
  if (typeof error === "string") {
    console.log("Error:", error);
  } else if (error instanceof Error) {
    console.log("Error:", error.message);
  }
}
```

Usar `unknown` nos obliga a manejar los errores con m√°s seguridad.