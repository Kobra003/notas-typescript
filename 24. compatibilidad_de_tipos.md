# Compatibilidad de Tipos en TypeScript

## Introducci√≥n

La **compatibilidad de tipos** en TypeScript define cu√°ndo un tipo se puede asignar a otro sin errores. A diferencia de lenguajes fuertemente tipados como Java o C#, TypeScript usa un sistema de tipos **estructural** en lugar de **nominal**.

üìå **Reglas clave de compatibilidad**:  
‚úî Un tipo con m√°s propiedades **no puede** asignarse a uno con menos.  
‚úî Un tipo con menos propiedades **s√≠ puede** asignarse a uno con m√°s (si contiene las requeridas).  
‚úî Las funciones son compatibles si sus par√°metros y retorno coinciden estructuralmente.  
‚úî Los tipos gen√©ricos y `any` siguen reglas flexibles.


## **Compatibilidad entre Tipos Primitivos**

Los tipos primitivos son compatibles de forma directa:

```typescript
let mensaje: string = "Hola";
let texto: string = mensaje; // ‚úÖ Compatible

let numero: number = 42;
let otroNumero: number = numero; // ‚úÖ Compatible
```

üö´ **No puedes asignar un tipo distinto sin conversi√≥n expl√≠cita:**

```typescript
let texto2: string = numero; // ‚ùå Error
```

‚úÖ **Conversi√≥n expl√≠cita:**

```typescript
let texto2: string = numero.toString(); // ‚úÖ Correcto
```


## **Compatibilidad entre Objetos**

TypeScript permite asignar un objeto a otro si **su estructura es compatible**.

### 1Ô∏è‚É£ **Ejemplo de compatibilidad (menos a m√°s propiedades)**

```typescript
type Persona = {
  nombre: string;
  edad: number;
};

let usuario = { nombre: "Juan", edad: 30, email: "juan@example.com" };
let persona: Persona = usuario; // ‚úÖ Compatible
```

**Explicaci√≥n:** `usuario` tiene una propiedad extra (`email`), pero **satisface** la estructura de `Persona`, por lo que es v√°lido.

### 2Ô∏è‚É£ **Ejemplo de incompatibilidad (m√°s a menos propiedades)**

```typescript
let personaInvalida: Persona = { nombre: "Ana" }; // ‚ùå Error: falta "edad"
```

üìå **Soluci√≥n:** Debemos incluir todas las propiedades necesarias.

```typescript
let personaValida: Persona = { nombre: "Ana", edad: 25 }; // ‚úÖ Correcto
```


## **Compatibilidad en Funciones**

Para que una funci√≥n sea compatible con otra, sus **par√°metros y valores de retorno** deben coincidir.

### 1Ô∏è‚É£ **Compatibilidad en Par√°metros**

```typescript
type Fn1 = (a: number, b: number) => number;
type Fn2 = (x: number, y: number, z: number) => number;

let sumar: Fn1 = (a, b) => a + b;
let operacion: Fn2 = sumar; // ‚úÖ Compatible (Fn1 tiene menos par√°metros)
```

**Regla:** Una funci√≥n con menos par√°metros **puede reemplazar** una con m√°s, pero no al rev√©s.

üö´ **Incompatibilidad (m√°s par√°metros a menos):**

```typescript
let operacionInvalida: Fn1 = (a, b, c) => a + b + c; // ‚ùå Error
```

No podemos asignar `Fn2` a `Fn1` porque `Fn1` espera solo 2 par√°metros.

### 2Ô∏è‚É£ **Compatibilidad en Retornos**

Si el tipo de retorno es **m√°s espec√≠fico**, la funci√≥n sigue siendo compatible.

```typescript
type FuncionBase = () => string;
type FuncionDerivada = () => "Hola";

let f1: FuncionBase = () => "Hola";
let f2: FuncionDerivada = f1; // ‚úÖ Compatible
```

**Regla:** Una funci√≥n que retorna un tipo m√°s **espec√≠fico** se puede asignar a otra que espera un tipo m√°s **gen√©rico**.

üö´ **Error cuando el retorno es incompatible:**

```typescript
let f3: FuncionBase = () => 42; // ‚ùå Error: number no es compatible con string
```


## **Compatibilidad con Tipos Gen√©ricos**

Los **tipos gen√©ricos** siguen las mismas reglas de compatibilidad que los tipos normales.

```typescript
type Caja<T> = { valor: T };
let cajaString: Caja<string> = { valor: "Texto" };
let cajaNumber: Caja<number> = { valor: 42 };

// ‚úÖ Compatible porque las estructuras coinciden
let cajaGenerica: Caja<string | number> = cajaString;
```

Un tipo gen√©rico con un **subtipo** puede asignarse a otro con un **supertipo**.

üö´ **Ejemplo de incompatibilidad:**

```typescript
let cajaInvalida: Caja<number> = cajaString; // ‚ùå Error
```

`Caja<string>` no es compatible con `Caja<number>`, aunque sus estructuras sean similares.


## **Compatibilidad con `any` y `unknown`**

TypeScript trata `any` y `unknown` de manera especial:

```typescript
let dato: any = "Hola";
let texto: string = dato; // ‚úÖ Compatible (pero sin seguridad de tipo)
```

`any` es compatible con cualquier tipo, pero **perdemos seguridad de tipos**.

üö´ `unknown` **requiere una verificaci√≥n antes de asignarse**:

```typescript
let datoDesconocido: unknown = "Hola";
let texto2: string = datoDesconocido; // ‚ùå Error

if (typeof datoDesconocido === "string") {
  let textoSeguro: string = datoDesconocido; // ‚úÖ Correcto
}
```

**Regla:** `unknown` solo es compatible tras una **verificaci√≥n de tipo**.


## **Covarianza y Contravarianza en TypeScript**

Estos t√©rminos definen c√≥mo los tipos pueden cambiar en relaciones de herencia.

### **Covarianza (Compatibilidad en Retornos)**

Un tipo derivado **puede reemplazar** a un tipo base si los retornos son compatibles.

```typescript
class Animal {
  hacerSonido(): string {
    return "Sonido gen√©rico";
  }
}

class Perro extends Animal {
  hacerSonido(): "Ladrido" {
    return "Ladrido";
  }
}

let miPerro: Animal = new Perro(); // ‚úÖ Compatible
```

### **Contravarianza (Compatibilidad en Par√°metros)**

Un tipo base **puede reemplazar** a un tipo derivado en los par√°metros de una funci√≥n.

```typescript
type Operacion = (n: number) => void;
type OperacionAvanzada = (n: number | string) => void;

let fn: OperacionAvanzada = (n) => console.log(n);
let fnBase: Operacion = fn; // ‚úÖ Compatible
```

**Regla:** Los par√°metros pueden ser **menos espec√≠ficos**, pero no m√°s.


## **Resumen**

‚úî **Compatibilidad estructural**: Un objeto con menos propiedades puede asignarse a otro con m√°s, pero no al rev√©s.  
‚úî **Funciones**: Una funci√≥n con menos par√°metros puede reemplazar a otra con m√°s, pero no al rev√©s.  
‚úî **Tipos gen√©ricos**: Siguen las mismas reglas que los tipos normales.  
‚úî **`any` es universalmente compatible**, pero `unknown` necesita verificaci√≥n previa.  
‚úî **Covarianza en retornos**, **contravarianza en par√°metros**.